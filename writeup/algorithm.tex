%!TEX root = main.tex

% =====================
% CHAPTER
% ---------------------
% =====================
\chapter{Algorithm}


% =====================
% SECTION
% =====================
\section{Goals}

Design goals:
\begin{itemize}
   \item Fast
   \item Minimal
   \item Take advantage of modern parallel hardware
\end{itemize}


% =====================
% SECTION
% =====================
\section{Problem Representation}

% =====================
% SECTION
% =====================
\section{Modified Bees algorithm}

% - Infeasible solutons admisible, just penalisted. Helps escape local minimum, like in TABUROUTE. 

% - Avoid the problem of Tabu Search moving cities around the depot more frequently, because removes are random. \cite{Taillard:1993}.

% - Takes advantage of Taillards observation that the move between tours don't need to be huge. It is suffient to move to the tour in an adjoining segment. This is achieved here by the NEAREST cities list, and much simplier and quicker.


% ---------------------
\subsection{Deeper driller}

% ---------------------
\subsection{Keeping Bees separate}

% ---------------------
\subsection{Tabu List}

% - GRAPH OF HOW SITES ARE KEPT DISTINCT, AND THERE SPREAD

% ---------------------
\subsection{Aged sites}

% - The problem with sending bees out to find random sites, and lopsided search, and how we fix it (aging of sites)

% ---------------------
\subsection{Selection of when to wonder around}

% - GRAPH OF ALL SITES PROGRESS, WITH RESTARTS


% =====================
% SECTION
% =====================
\section{Problem Initiation}

%   * Intial starting thingie ? k-means
% We use kmeans clustering. The kmeans algorithm isn't guaranteed to produce the same result each run. This is conventionally viewed as limitation of the algorithm. However for our purpose this is an advantage as we can use the randomness to better seed the population with different solutions.  


% =====================
% SECTION
% =====================
\section{Large Neighbourhood Search}

% ---------------------
\subsection{Destroy}

% - Worst
% - Random

% dependent on how the partial solution is repaired. Shaw [51] proposed to gradually increase the degree of destruction, while Ropke and Pisinger [45] choose the degree of destruction randomly in each iteration by choosing the degree from a specific range dependent on the instance size. The destroy method must also be chosen such

% ---------------------
\subsection{Repair}

% - Random best (random order)

% - Candidate lists

    % However, from a diversification point of view, an optimal repair operation may not be attractive: only improving or identical-cost solutions will be produced
