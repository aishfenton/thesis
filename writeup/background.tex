%!TEX root = main.tex

% =====================
% CHAPTER
% ---------------------
% =====================
\chapter{Background}
This section reviews the background of Vehicle Routing Problem (\VRP) and Pickup Delivery Problem (\PDP). Classic and more modern heuristics for solving the \VRP\ and related problems are reviewed as well providing a review of real-world implementations and results. 

% =====================
% SECTION
% =====================
\section{\TSP\ introduction and history}
The traveling salesman problem can informally be defined as given $n$ points on a map provide a route through each of the $n$ points such that each point is only used once and the total distance travelled is minimized. The problem's name, traveling salesman, comes from the classic real-world example of the problem: a salesman is sent on a trip to visit $n$ cities. What is order should she visit the cities in, such that she covers the least distance? See figure \ref{fig:tsp_example}

\picscl{images/background.pdf}{Traveling Salesman Problem}{fig:tsp_example}{0.75}

\TSP\ is related to a classic graph theory problem, the Hamiltonian path. Hamiltonian circuits have been studied since 1856 by both Hamilton \cite{Hamilton:1856} and Kirkman \cite{Kirkman:1856}. The traveling salesman problem has been informally discussed probably for many years \cite{Schrijver} but didn't become actively studied until after 1928 where Menger, Whitney, Flood and Robinson produced much of the early results in the field. Robinson's RAND report \cite{Robinson:1949} might have been the first article to call the problem by the name it has since become known, the Traveling Salesman Problem.  

\quote{
  The purpose of this note is to give a method for solving a problem related to the traveling salesman problem. One formulation is to find the shortest route for a salesman starting from Washington, visiting all the state capitals and then returning to Washington. More generally, to find the shortest closed curve containing $n$ given points in the plane.
}

An early result was provided by Dantzig, Fulkerson, and  Johnson \cite{Dantzig:1954}. Their paper gave an exact method for solving a 49 city problem, a large number of cities for the time. Their algorithm used the cutting plane method to provide an exact solution. This approach has been the inspiration for many subsequent approaches, and is still the bedrock of algorithms that attempt to provide an exact solution.  

Karp's famous paper, Reducibility Among Combinatorial Problems, in 1972 showed that the Hamiltonian Circuit problem is NP-complete. This implied the NP-hardness of \TSP, and thus supplied the mathematical explanation for the apparent difficulty of finding optimal tours.

A generalization of \TSP is \MTSP, where multiple routes are allowed to be constructed (i.e. multiple salesman can be used to visit the cities). The pure \MTSP\ can trivially be turned into a \TSP by constructing a graph $G$ with $n - 1$ additional copies of the starting node to the graph and forbidding travel directly between each $n$ starting nodes. Note however that the pure formulation of \MTSP\ places no additional constraints on a route. In real life applications \MTSP\ is typically employed with additional constraints, such as each route should be of equal size (e.g. work should be balanced among the salesman), or no route should exceed a total distance or time (e.g. a anyone salesman shouldn't be asked to work more than 8 hours a day). 

\MTSP leads us naturally into the a class of problems derived from the Vehicle Routing Problem (\VRP). \VRP -- and it's family of related problems -- can be understood as being a combination of \MTSP\ along with  other constraints, which are in themselves often combinatorially hard problems.    

% =====================
% SECTION
% =====================
\section{\VRP\ introduction and history}
The Vehicle Routing Problem (\VRP) seeks to solve the problem of constructing routes for a fleet of vehicles. Each route takes the vehicle through a set of customers to deliver a good (or service) at different locations. The routes must be constructed such that all constraints are meet, classically, the vehicle's capacity isn't exceeded by the number of customers being serviced. The goal is to minimize the cost of distributing the goods, which typically has meant minimizing the distance travelled across all routes.

% The large number of real-world applications, both in North America and Europe, have widely shown that the use of computerized procedures for the distribution process planning produces substantial savings (generally 5\% to 20\%) in globabl transportation costs. http://books.google.co.nz/books?hl=en&lr=&id=TeMgA5S74skC&oi=fnd&pg=PR5&dq=vehicle+routing+problem+history&ots=AhY2KbKu40&sig=F-oubQFGcQzDw-RODKMXg2C-jX8#v=onepage&q=vehicle%20routing%20problem%20history&f=false

\VRP\ was first formally defined by Dantzig and Ramser, in \cite{Dantzig:1959} and has remained an important problem in logistics and transport (the original name given to the problem presented by Dantzig and Ramser was The Truck Scheduling Problem). The Vehicle Routing Problem is closely related to two problems, the Multiple Traveling Salesman Problem \MTSP\ and the Bin Packing Problem \BPP.

% =====================
% Sub Section
\subsection{Exact Methods}

The first efforts were concerned with exact solutions, and proceeded using many of the same techniques brought to bear on \TSP. 
We follow Laporte and Nobert's survey \cite{LANO:87} and classify exact algorithms for the \VRP\ into three families: Direct tree search methods, Dynamic programming, and Integer linear programming.

The first classic Direct tree search results are due to Christolds and Ellison. Their 1969 paper in Operations Research Quarterly provided the first branch and bound algorithm for exactly solving the \VRP \cite{CE:1969}. Unfortunately it's time and memory requirements where such that it was only able to solve problems of up to 13 customers. This result was later improved upon by Christolds in 1976 by using a different branch model. This improvement allowed him to solve for up to 31 customers. 

Christofides, Mingozzi, and Toth, \cite{CMT:1981} provide a lower bound method that is sufficiently quick (in terms of runtime performance) to be used to as a lower bound for excluding nodes from the search tree. They used this method to provide solutions as for a number of problems containing between 15 to 25 customers. Laporte, Mercure and Nobert \cite{LMN:1986} used \MTSP\ as a relaxation of \VRP\ within a branch and bound framework to provide solutions for 'realisticly' sized problems containing up to 250 customers.  

The Dynamic Programming approach was first proposed for \VRP\ by Eilon, Watson-Gandy and Christofides (1971). Their approach allowed them to solve exactly for problems of 10 to 25 customers. Since then, Christofides has made improvements to this algorithm to solve exactly for problems up to 50 vertices large.

A Set Partitioning algorithm was given by Balinski, and Quandt in 1964 to produce exact \VRP\ solutions \cite{balinski:64}. The problem sets they used where very small however, having only between 5 to 15 customers. And even despite this they weren't able to produce an solution for some of the problems. However, taking their approach as a starting point many authors have been able to produce more powerful methods. Rao and Zionts (1968), Foster and Ryan (1976), Orloff (1976), Desrosiers, Soumis and Desrochers (1984), Agarwal, Mathur and Salkin (1989), and Desrochers, Desrosiers and Solomon (1990), have all extended the basic set partitioning algorithm, using the Column Generation method, to produce more practically useful results. 

Notwithstanding the above results, exact methods have been of more use in advancing theoretical understanding of \VRP\ than to providing solutions to real life problems. This can mostly be attributed to the fact that real-life \VRP\ instances often involve hundreds of customers, and involve richer constraints than are modeled in a simple \VRP.

% =====================
% Sub Section
\subsection{Classic Heuristics}
Classic \VRP\ heuristics can be classified into three families. Constructive heuristics; Two-phase heuristics, which again can be classified into two sub-families: cluster first and then route, and route first and then cluster; and Improvement methods.

We start by looking at Constructive heuristics. Constructive heuristics build a solutions from the ground up. They typically provide a recipe for building each route, such that the total cost of all routes is minimized. An early and influential result was given by Clarke and Wright in their 1964 paper, Scheduling of vehicles from a central depot to a number of delivery points \cite{clark:1964}. In this paper they present a heuristic method for solving \VRP\ problems that improved upon Dantzig and Ramser's work -- it is commonly known as the Clarke-Wright heuristic. The heuristic is based on the simple process of combining routes (starting with each route containing a single customer) such that 

The heuristic has been used to solve problems of up to 1000 customers with results often within 10\% of optimal using only a 180 seconds of runtime \cite{TV2001}. This classic algorithm has been extended by Gaskell (1967), Yellow (1970) and Paessens (1988), who have suggested alternatives to the savings formulas used by Clarke and Wright. These approaches typically introduce additional parameters to guide the algorithm towards selecting routes with geometric properties that are likely to produce better results.  

Alk

---


Gillett and Miller provided a new method called the sweep algorithm in their 1974 paper. This popularized the two-phase approach, although this method was suggested earlier by Wren in his 1971 book, and subsequently in Wren and Holliday's 1972 paper for Operations Research Quarterly. In this approach, a initial clustering phase is used to cluster the customers into a  base set of routes. From here the routes are treated a separate \TSP\ and optimized accordingly. The two-phase approache typically doesn't prescribe a method for how the \TSP\ is solved and assumes that already developed \TSP\ methods will be used. The classic sweep algorithm uses a simple geometric method to cluster the customers, and has been shown to solve several benchmark \VRP\ problems to within 2\% to 9\% of the best known solutions \cite{TV2001}.

Fisher and Jaikumas's 1981 paper builds upon the two-phase approach by providing a more sophisticated clustering method. They solve a General Assignment Problem to form the clusters instead. A limitation of their method is that the amount of vehicle routes must be fixed up front. Their method often produces results that are 1\% to 2\% better than similar results produced by the classic sweep algorithm \cite{TV2001}.

% RESULTS TABLE FROM VRP BOOK / PAPER

% – cluster first, route second (Fisher, Jaikumas, Net- works, 1981)
% – intra-route improvement methods (TSP heuristics)
% – inter-route improvement methods (λ-interchanges, Osman, 1993; cyclic exchanges, Thompson and Psaraf- fis, 1993; edge exchange schemes, Kindervater and Savelsbergh, 1997; ejection chains (Xu and Kelly, 1996; Rego and Roucairol, 1996; Rego, 1998); very large neighbourhood search (Ergun et al., 2003)
% – SERR (De Franceschi, Fischetti, Toth, working pa- per, 2004)
% --
% 1989 First tabu search implementation (Willard, M.Sc. thesis, Imperial College)
% 1991  First version of Taburoute (Gendreau, Hertz, Laporte, Tristan I Conference)
% 1993  Tabu search (Taillard, Networks)
% 1993 Simulated Annealing and tabu search (Osman, Annals of Operations Research)
% 1994  Taburoute (Gendreau, Hertz, Laporte, Management Science)
% 1995 Adaptive memory (Rochat, Taillard, Journal of Heuristics)
% 1996  Ejection chains (Rego, Roucairol, Meta-Heuristics: Theory and Applications)
% 9
% 2001 Unified tabu search algorithm (Cordeau, Laporte, Mercier, Journal of the Operational Research Society)
% 2002  Adaptive memory (Tarantilis, Kiranoudis, Annals of Operations Research)
% 2003  Granular tabu search (Toth, Vigo, INFORMS Journal on Computing)
% 2003 Very large neighbourhood search (Ergun, Orlin, Steele-Feldman, working paper, MIT)
% 2004 Deterministic annealing (Li, Golden, Wasil, Computers & Operations Research)
% 2004  Population search (Prins, Computers & Operations Research; Mester and Br ̈aysy, Computers & Opera- tions Research)
% 2004 Ant systems optimization (Reinmann, Doerner, Hartl, Computers & Operations Research)
% 2005  Attribute based hill climber heuristic (Derigs, Kaiser)

\VRP\ is one of the most the studied combinator optimization problems. Hundreds of papers been written on it  

Out of \VRP\ comes a family of related problems. These attempt to model other constraints that are encountered in real-world applications of the \VRP. Classic problems have included: \VRP\ with Time Windows that introduces a time window constraints  against each customer, that the vehicle must arrive within. \VRP\ multiple depot, where the vehicles are displayed from multiple start points. \VRP\ with Pick   

% =====================
% Sub Section
\subsection{\VRPTW}

% =====================
% Sub Section
\subsection{\PDPTW}


% =====================
% SECTION
% =====================
\section{An introduction to classic \VRP\ heuristics}

This section reviews some of the more common heuristics algorithms. 

% =====================
% Sub Section
\subsection{Construction algorithms}
These following algorithms are heuristics for constructing an initial solution

% ---------------------
\subsubsection{Nearest neighbour}
The most simple algorithm, this codifies the intuitive principle of constructing a solution by picking the job to the depot, then the closest job to this, and so on until a route is filled.

Formally the algorithm creates the sequence $R = \seq{v_0}$ and picks $v \in V$ such that $d_{0,i}$ is minimized. It repeat this until the route represented by $R$ is exceeds it capacity. Then a new route $R$ is constructed and the process is repeated with the remaining jobs. This continues until all jobs are allocated.

Although the Nearest Neighbour algorithm is simple to understand and implement it situations can occur where the performance is bad

% ---------------------
\subsubsection{Nearest insertion}

The algorithm was first proposed by ?

This algorithm slightly improves upon the previous algorithm. The algorithm proceeds much the same as the Nearest Neighbour algorithm but instead of considering only the previous node it considers the entire sequence of jobs route so far in $R$. It finds an insertion point along $R$ such that for job $v_k$ insertion between vertices $v_i, v_j$ the function $c_{ik} + c_{kj} - c_{ij}$ is minimized.

% ---------------------
\subsubsection{Clark and Wright algorithm}

Clark-Wright's widely known construction algorithm first appeared in \cite{clark:1964}. The algorithm uses a concept of \emph{savings}. The algorithm starts with a separate route for each customer: from depot, to customer, and back to the depot. A saving value is calculated for every pair of customers. The saving value is the distance saved by one customer being serviced directly after the other without returning to the depot in between -- in other words the savings gained by combining two partial routes. Routes are then merged based on the largest savings.

The algorithm comes in two flavours: sequential and parallel. The sequential version sequentially adds customers to a route until a route has reached capacity (or based on some other constraint such as maximum route length) and then produces the next. The parallel version builds each route in parallel. The parallel version out performs the sequential version in most cases\cite{Laporte:1999} and is the version considered in our approach.

The algorithm is surprising adaptable and has been extended to deal with more specialized vehicle routing problems were additional objectives and constraints must be considered. The algorithm's flexibility derives from its algebraic treatment of the problem rather than exploiting the problem's underlying spatial properties, as many of the two-phase algorithms do \ref{2phasealgorithms}. The algorithms savings formula can be adjusted to accommodate other objectives. An example of this is Solomon's equally ubiquitous algorithm \cite{Solomon:1987} which extends the Clark and Wright algorithm to cater for time constraints. 

The algorithm works as follows:

\begin{itemize}
	\item Prime the solution with routes $R = \set{x_0, x_i, x_0}$ for all jobs $x_i \in X$.
	\item For all $i,j$ calculate $s_{ij} = c_{i0} + c_{j0} - c_{ij}$.
	\item Process each $S_{ij}$ in descending order, find routes $r_1 \in R : r_1 = \set{0,...,x_i,x_0}$ and $r_2 \in R: r_2 = \set{0,x_j,...,0}$. Merge these together such that $R' = \set{0,...,x_i, x+j,...,0}$. Stop once capacity constraints or route length constraint is exceeded.
\end{itemize}

\picscl{images/background-cw.pdf}{Clark Wright Savings Algorithm}{fig:cw_savings}{0.75}


% =====================
% Sub Section
\subsection{2-phase construction algorithms}
\label{2phasealgorithms}

% ---------------------
\subsubsection{Cluster first}

We use kmeans clustering. The kmeans algorithm isn't guaranteed to produce same result each run. This is conventionally viewed as limitation of the algorithm. However for our purpose this is an advantage as we can use the randomness to better seed the population with different solutions.  

% ---------------------
\subsubsection{Sweep}


% =====================
% Sub Section
\subsection{Improvement heuristics}

% ---------------------
\subsubsection{2-opt}

% ---------------------
\subsubsection{Or-opt}

% ---------------------
\subsubsection{Or-opt improvements}

% ---------------------
\subsubsection{GENI}

% ---------------------
\subsubsection{$\lambda$-interchanges}

% ---------------------
\subsubsection{Ejection chains}
\hquote{I want to know more about ejection chains}


% =====================
% Sub Section
\subsection{Meta-heuristics}

% ---------------------
\subsubsection{Tabu search}

% ---------------------
\subsubsection{Genetic algorithms}

% ---------------------
\subsubsection{Memetic algorithms}

% ---------------------
\subsubsection{Large neighbourhood search}


% =====================
% SECTION
% =====================
\section{Real-world implementations}




